# Adaptaki Backend

## Назначение

Backend — это API-ядро платформы Adaptaki.
Он отвечает за:

-   авторизацию и роли пользователей,
-   бизнес-логику обучения (в будущем),
-   работу с БД,
-   интеграцию с ИИ,
-   предоставление API для разных клиентов (Web, Mobile, Telegram).

Backend **не рендерит HTML** и используется только как API.

---

## Текущий статус (зафиксировано)

На данный момент реализовано:

### ✅ Инфраструктура

-   Django
-   Django REST Framework
-   PostgreSQL / SQLite (dev)
-   Структура с папкой `apps/`
-   CORS настроен для локальной разработки

### ✅ Пользователи и авторизация

-   Кастомная модель `User`
-   JWT-аутентификация (`SimpleJWT`)
-   Эндпоинты:
    -   `POST /api/auth/register/`
    -   `POST /api/auth/login/`
    -   `GET  /api/auth/me/`

### ✅ Архитектурные договорённости

-   Django используется как:
    -   API-слой
    -   ORM
    -   инфраструктура
-   Бизнес-логика выносится из views
-   Проект ориентирован на **backend-first архитектуру**

---

## Структура проекта

backend/
├─ config/ # Django project (settings, urls)
├─ apps/ # Django apps
│ ├─ users/ # Пользователи и авторизация
│ └─ learning/ # Учебные сценарии (пока пусто)
├─ domain/ # Чистая доменная логика (пока заготовка)
├─ application/ # Use cases / сценарии (пока заготовка)
├─ infrastructure/ # Репозитории, интеграции (пока заготовка)
├─ manage.py
└─ requirements.txt

---

## Важные правила (НЕ НАРУШАТЬ)

-   ❌ Не писать бизнес-логику во `views`
-   ❌ Не привязывать домен к HTTP / DRF
-   ✔ Использовать JWT для всех защищённых эндпоинтов
-   ✔ Новые сценарии реализовывать как отдельные use case

---

## Что делать дальше (следующие шаги)

Ближайшие логичные шаги backend-разработки:

1. Реализовать первый бизнес-сценарий:
    - `POST /api/answers/submit`
2. Добавить модели:
    - Task
    - Attempt
3. Начать заполнять `domain/` и `application/`
4. Подготовить backend к Telegram Mini App

---

## Архитектурные принципы (обязательные)

Graph-first
Граф знаний — ядро системы. Экзамены, задания и рекомендации лишь используют его.

Node — универсальная единица знания
Нет отдельных сущностей «навык», «закон», «пример» — это разные типы одного Node.

Контекст через связи, а не через поля
Принадлежность к предмету, теме, экзамену — это связи, не атрибуты.

Экзамен ≠ обучение
Экзаменационный контур не управляет графом знаний и не модифицирует его.

Попытка решения — атом аналитики
Любая аналитика строится от TaskAttempt, а не от теста целиком.

---

## Планируемые приложения и модели (в разработке)

Ниже — согласованная структура приложений и основных сущностей.

### apps.exams (экзамены и рубрикатор)

-   `Exam` — вид экзамена (например, ЕГЭ)
    -   `title`
-   `ExamType` (возможный будущий rename: `ExamTrack`) — экзамен + предмет (например, ЕГЭ по математике)
    -   `exam`, `subject`, `is_active`
-   `ExamTaskGroup` — группа/номер задания внутри экзаменационного трека (например, №13, Планиметрия)
    -   `exam_type`, `num`, `title`, `is_active`
    -   важно: `task_type`, `scoring_policy`, `max_score`
-   `ExamTaskType` — подтип внутри группы (опционально; для более детальной рубрикации)
    -   `exam_task_group`, `title`, `is_active`

### apps.graph (образовательный граф)

-   `Subject` — предмет (например, Математика)
    -   `title`
-   `Concept` — тема/концепция (например, Квадратные уравнения)
    -   `title`, `description`
-   `Node` — вершина графа (знание/навык/понятие)
    -   `title`, `type`, `subject`, `concept`
-   `Relation` — ребро графа
    -   `parent`, `child`, `type`

### apps.tasks (банк заданий)

-   `Task` — задание
    -   базовые поля: `subject`, `task_type`, `prompt` (markdown + LaTeX), `solution_text` (markdown + LaTeX)
    -   расширение: `type_payload` (JSON), `answer_key` (JSON)
    -   связи:
        -   `exam_task_type_id` (nullable) — ссылка на рубрикатор (если задание относится к конкретному типу/номеру экзамена)
        -   M2M к `graph.Node` — какие вершины графа затрагивает задание

### apps.training (тесты, попытки, результаты)

-   `Test` — заранее подготовленный тест (цепочка заданий)
    -   `title`, `subject`, `mode` (например: simple/exam)
-   `TestItem` — место задания в тесте
    -   `test`, `task`, `order`, `max_score`
    -   (для exam-mode) ссылка на рубрикатор/группу для применения политики оценивания
-   `TestAttempt` — попытка прохождения теста (контейнер)
    -   `user`, `test`, `status`, `started_at`, `finished_at`, `total_score`, `max_score`
-   `TaskAttempt` — атомарный факт решения задания (используется и в тестах, и вне тестов)
    -   `task`, `user`, `answer_payload` (JSON), `score`, `is_correct`, `submitted_at`
    -   `test_attempt_id` (nullable) — если решение происходило в рамках конкретного теста

Примечание: в exam-режиме политика оценивания берется из рубрикатора экзамена (например, из `ExamTaskGroup`) и применяется при проверке ответа.
